---
layout: post
title: "大话数据结构：树"
date:  2020-06-16 10:01:08
author: "Viletyy"
header-style: text
tags:
  - 数据结构
---
## 树
树（Tree）是n（n>=0）个结点的有限集。n=0时称为空树。在任意一棵非空树中：

1. 有且仅有一个特定的称为根（Root）的结点；
2. 当n>1时，其余结点可以分为m（m>0）个互不相交的有限集T1，T2，...，Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。


对于树的定义还需要强调两点：

1. n>0时根结点是唯一的，不可能存在多个根结点，别和现实中的大树混在一起，现实中的树有很多根须，那是真实的树，数据结构中的树是只能有一个根结点。
2. m>0，子树的个数没有限制，但它们一定是互不相交的。

### 结点分类
树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度（Degree)。度为0的结点称为叶结点（Leaf）或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。

### 结点间关系
结点的子树的根称为该结点的孩子（Child），相应地，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之间互称兄弟（Sibling）。结点的祖宗是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任意结点都称为该结点的子孙。

### 树的其它相关概念
结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第一层，则其子树的根就在第1+1层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。

如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称为该树为有序树，否则称为无序树。

森林（Forest）是m（m>=0)棵互不相交的树的集合。对树中每个结点而言，其子树的结点集合则为森林。

对比线性表与树的结构：

* 线性结构
    * 第一个数据元素：无前驱
    * 最后一个数据元素：无后继
    * 中间元素：一个前驱一个后继
* 树结构
    * 根结点：无双亲，唯一
    * 叶结点：无孩子，可以多个
    * 中间结点：一个双亲，多个孩子。

### 树的抽象数据类型
```c
ADT 树(tree)
Data
    树是由一个根结点和若干棵子树构成的。树中结点具有相同数据类型及层次关系
Operation
    InitTree(*T): 构造空树T。
    DestroyTree(*T): 销毁树T。
    CreateTree(*T, definition): 按definition中给出树的定义来构造树。
    ClearTree(*T): 若树存在，则将树T清为空树。
    TreeEmpty(T): 若T为空树，返回true，否则返回false。
    TreeDepth(T): 返回T的深度。
    Root(T): 返回T的根结点。
    Value(T, cur_e): cur_e时树T中一个结点，返回此结点的值。
    Assign(T, cur_e, value): 给树T的结点cur_e赋值为value。
    Parent(T, cur_e): 若cur_e是树T的非根结点，则返回它的双亲，否则返回空。
    LeftChild(T, cur_e): 若cur_e时树T的非叶结点，则返回它的最左孩子，否则返回空。
    RightSibling(T, cur_e): 若cur_e有右兄弟，则返回它的右兄弟，否则返回空。
    Insert(*T, *p, i, c): 其中p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树。
    DeleteChild(*T, *p, i): 其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树。
endADT
```

### 树的存储结构

#### 双亲表示法
在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。

其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点双亲在数组中的下标。
```c
/*树的双亲表示法结点结构定义*/
#define MAX_TREE_SIZE 100
typedef int TElemType; /*树结点的数据类型，目前暂定为整型*/
typedeff struct PTNode /*结点结构*/
{
    TElemType data; /*结点数据*/
    int parent; /*双亲位置*/
} PTNode;
typedef struct 
{
    PTNode nodes[MAX_TREE_SIZE]; /*结点数组*/
    int r, n; /*根的位置和结点数*/
} PTree;
```
有了这样的结构定义，我们就可以来实现双亲表示法了。由于根结点是没有双亲的。所以我们约定根结点的位置域设置为-1，这也就意味着，我们所有的结点都存有它双亲的位置。

这样的存储结构，我们可以根据结点parent指针很容易找到它的双亲结点，所用的时间复杂度是O(1)，直到parent为-1时，表示找到了树结点的根。可我们要知道结点的孩子是什么，对不起，请遍历整个结构才行。

我们增加一个结点最左边孩子的域，不妨叫它长子域，这又就可以很容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为-1。

对于有0个或1个孩子结点来说，这样的结构是解决了要找结点孩子的问题了。甚至是有2个孩子，知道了长子是谁，另一个当然就是次子了。

另一个问题场景，我们很关注各兄弟之间的关系，双亲表示法无法体现这样的关系，可以增加一个右兄弟域来体现兄弟关系，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果右兄弟不存在，则赋值为-1。

但如果结点的孩子很多，超过了2个。我们又关注结点的双亲，又关注结点的孩子，还关注结点的兄弟，而且对时间遍历要求还比较高，我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。存储结构的设计是一个非常灵活的过程。一个存储结构设计得是否合理，取决于给予该存储结构的运算是否适合、是否方便、时间复杂度好不好等。注意也不是越多越好，有需要时再设计相应的结构。

#### 孩子表示法
由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。

**方案一**

一种是指针域的个数就等于树的度。
其中data是数据域。child1到childd是指针域，用来指向该结点的孩子结点。

这种方法对于树中个结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的空间被充分利用了，这时存储结构的缺点反而变成了优点。

**方案二**
每个结点指针域的个数等于该结点的度。我们专门取一个位置来存储结点指针域的个数。
其中data为数据域，degree为度域，也就是存储该结点的孩子结点的个数，child1到childd为指针域，指向该结点的各个孩子的结点。

这种方法客服来浪费空间的缺点，对空间利用率是很高了，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。

**孩子表示法**是把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。

为此，设计两种结点结构，一个是孩子链表的的孩子结点。
其中child是数据域，用来存储某个结点在表头数组中的下标。next是指针域，用来存储指向某结点的下一个孩子结点的指针。

另一个是表头数组的表头结点。
其中data是数据域，存储某结点的数据信息。firstchild是头指针域，存储该结点的孩子链表的头指针。
```c
/*树的孩子表示法结构定义*/
#define MAX_TREE_SIZE 100
typedef struct CTNode /*孩子结点*/
{
    int child;
    struct CTNode *next;
} *ChildPTr;

typedef struct /*表头结构*/
{
    TElemType data;
    ChildPtr firstchild;
} CTBox;

typedef struct /*树结构*/
{
    CTBox nodes[MAX_TREE_SIZE]; /*结点数组*/
    int r, n; /*根的位置和结点数*/
} CTree;
```

#### 孩子兄弟表示法
任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟若果存在也是唯一的。因此，我们设置两个指针，分别只想该结点的第一个孩子和此结点的右兄弟。

其中data是数据域，firstchild为指针域，存储该结点的第一个孩子结点的存储地址，rightsib是指针域，存储该结点的右兄弟结点的存储地址。

```c
/*树的孩子兄弟表示法结构定义*/
typedef struct CSNode
{
    TElemType data;
    struct CSNode *firstchild, *rightsib;
} CSNode, *CSTree;
```

参考资料：

- [大话数据结构]()