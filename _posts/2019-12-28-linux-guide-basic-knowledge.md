---
layout: post
title: "开源世界旅行手册：基础知识"
date:  2019-12-28 10:28:00
author: "Viletyy"
header-style: text
tags:
  - Linux
---
## 基础知识

### Shell

可能您早已能够熟练的使用 GUI（图形用户界面），例如您可以使用鼠标双击一个图标，来打开或者执行它。

我们来看这个过程: 您使用鼠标定位桌面上的一个程序图标，按下左键两次。系统读取鼠标指针的位置，并且判断该位置下图标的涵义，根据预设的双击动作，运行程序或者打开文件。

这一套 GUI 系统，便是一种 Shell，它的作用是实现人机交互。如果我们不能够控制电脑，那么电脑还不如电视机好玩，不是么？电视机也可以选择频道（电视机的遥控器，也是一种人机交互的界面，不过相对于电脑，确实是相当简单了）

易于上手、界面直观是 GUI 的优点，但是 GUI 并不意味着简单！或许您有类似经历: 桌面上有几十个程序的启动图标，也知道它们的名字，但是翻出一个来，并不是一件轻松的事情。

我的 Windows 系统中，桌面上摆满了各种图标，每当启动一个程序的时候，我都很是困扰。后来尝试了 音速启动 这类程序启动管理器，效果却不遂人意。（在我的不懈努力下，这个难道最终得到了解决： 将快捷方式名称简化，放到特定目录下，使用 Win+R 组合键呼出 运行 对话框，键入快捷方式的名称来运行该程序。比如 反恐精英 的快捷方式为 cs ，我把它放在 Windows 目录下; 运行 cs 命令，就可以去维护世界和平了。
 这么多快捷方式，统统放到 Windows 目录下，非常混乱。因此，我在 D盘 建立了一个名为 path 的目录，并把它的路径加入到环境变量的 path 项中，快捷方式放在 D:\path 目录中。即便重装系统，只要在环境变量中重新加入此路径，原来的程序大多可以直接以命令来运行……我的许多朋友强烈要求我帮他们设定这种启动方式，因为这确实很方便：））

在 Linux 下，所有的程序都可以通过命令运行。虽然 Linux 也有 GUI，但是它并不比 Windows 的 GUI 更优秀！上面只是简单的介绍了 CLI（命令行界面）相对 GUI 的优越之处，使用 CLI 还有更多的好处，您会慢慢体会到的。

当然了，在您的印象中，CLI 一定非常的不友善，缺少亲和力，冷漠而拒人于千里之外……您和 CLI 之间甚至有代沟的存在

### 命令

坦白的说，冷不丁见到那么老长的一串命令，谁都会毛骨悚然。

也许您使用过DOS，留下这种印象：命令先放一边，光是正确的输入目录、文件名都够瞧的。而且DOS不区分大小写，要是像Linux一样区分大小写，那多恐怖啊！！！

其实Linux命令行具有补全功能，非常实用。假设有这样一个命令：

```shell
command path/file
```

如果只有一个以`c`起始的命令，键入`c`，再按一次`tab`键，系统将自动补全该命令余下的部分。只要`c` `tab`两次按键，就可以完成`command`的输入。

现在我们来了解命令的语法结构，这一部分相当重要，您可得看仔细。

我们知道，任何语言都有特定的语法结构，以我们的中文为例：

```shell
我们①郑重地②推荐③您Linux④！
```

　这个句子的语法尽管简单，却是大部分的命令行采用的句型。让我们看一下，这个句子里都有些什么。

① 主语，Linux命令的执行者当然是用户，所以主语一概省略。

② 状语，用来修饰谓语。与之相对应，Linux命令可以使用选项来精细调节程序的行为。为了与命令的操作对象相区别，选项前通常要加-或者--符号。原则上，在命令名后，选项的位置可以随意，但是为了养成一个良好的习惯，我们建议您在命令名后直接跟选项。

③ 一个动词，作为谓语而存在。Linux命令中，这一步是必须的。这一部分也是不同命令之间最根本的区别方式，所以它通常作为命令名，写在最前面。键入date命令，您可以查看当前的日期。

④ 这两个部分都是宾语，它们是命令的操作对象。大部分的命令只有一个操作对象，也有一些命令是双宾语结构的，具有一个直接宾语和间接宾语。比如拷贝这个命令`cp`（copy）（`cp a b `表示把文件a拷贝为文件b）（`cp a /home` 表示把当前目录下的a文件，拷贝到/home目录下。）（命令的不同部分使用空格分隔，连续的空格视为一个空格）

分隔符，我们的汉语是象形文字，没有分隔符。但是所有的拼音文字中都用空格作为分隔符，来分隔单词。Linux命令中同样使用空格作分隔符。

上面的那句话，翻译成Linux的命令，应该是这个样子的：

```shell
推荐 --①郑重地 您 Linux
```

① 按照传统，“-”后跟选项缩写，“--”后跟选项全称。不过也有例外

哈，Linux的命令也蛮简单吧？

### Linux程序、进程

或许您会这样想，Linux命令的句型确实不难，但是那么多命令，我这么知道它们都是作什么的呢？而且不同的系统中，可以使用的命令似乎也不太一样，这真让人困惑。。。

其实Linux的命令，运行的是Linux系统中的程序。只要您已安装了程序，您就可以通过命令来运行它，并且可以使用选项来精细的调整它的运行状态。也可以通过点击启动图标来运行，不过启动图标不能够方便的调整选项，并不是很方便。

举一个例子：

```shell
mplayer -shuffle -loop 3 -playlist mymp3.list
```

可能您运行上面命令，系统会提示您无法找到命令，那是因为您没有安装mplayer这个程序。mplayer是我见过的支持格式最多的播放器，几乎任何已知格式的多媒体文件，都可以使用mplayer来播放。它包含一个图形界面的前端，您可以在菜单中找到它，鼠标点击运行；也可以通过执行命令来运行它的命令行版本。

如果您的系统中没有mplayer播放器，我们建议您安装一个。关于程序的安装，参阅第16章 软件管理。

上面命令中，mplayer调用了mplayer播放器程序。选项-shuffle表示随机播放，-loop表示循环播放，后面的3为循环的次数，如果为0，则为一直播放。-playlist 表示播放列表中的曲目。我们可以把mp3的路径放到mymp3.list文件中，让mplayer来播放它们。

**进程**，为运行中的程序，是程序在内存中的镜像。

好了，现在您已经了解了Shell、命令、程序、进程的概念，您基本上也就了解了Linux（Linux系统真是非常简洁，而且容易理解）

但只知道这些，您并不能顺畅使用。接下来的章节中，我们来进一步介绍它的细节。

### 路径

路径分为绝对路径和相对路径。

绝对路径的起始点为根目录`/`，例如/usr/local/bin就是绝对路径，它指向系统中一个绝对的位置，不受其他因素影响。

相对路径的起始点为当前目录，如果您现在位于/usr目录，那么相对路径local/bin所指示的位置为/usr/local/bin

也就是说，相对路径所指示的位置，除了相对路径本身，还受到当前位置的影响。例如Linux系统中常见的目录/bin, /usr/bin, /usr/local/bin, 如果只有一个相对路径bin，那么它指示的位置可能是上面目录中任意一个，也可能是其他目录。

如果我告诉您到bin目录寻找一个文件，您可能搞不清楚是哪一个bin目录。只有当前位置确定，相对路径指示的位置才能够确定。

现在我说，/usr/local目录下，它的相对路径bin中有某个文件，这样就比较明确了。

在相对路径中，`.`表示当前目录，`..`表示当前目录的上一级目录。

假设您安装了一个程序，它的主程序没有被放置到上面三个bin目录中的任何一个，或者其他系统能够找到的地方，您就得告诉系统，它的可执行文件在哪里。

可以使用绝对路径，例如： **/home/user/bin/可执行文件**

或者定位到/home/user/bin目录，使用相对目录来定位它 **./可执行文件**

路径相关命令：

```shell
cd (change directory) # 更改目录
pwd (print working directory) # 显示当前路径
ls (list) # 显示当前目录中的文件列表
```

请尝试一下操作：

```shell
cd /etc # 进入 “/etc/”目录，这里使用的是绝对路径
pwd # 显示当前路径，这个命令返回结果“/etc”
cd init.d # 进入 “/etc”目录的子目录“init.d”，这里使用的是相对路径
cd .. # 进入上一级目录“/etc”
cd ../home # “/etc”目录的上一级目录为“/”，它的子目录“home”为“/home”
cd - # 回到上一次的目录，我们在“/etc”目录跳转到“/home”目录，所以这次是回道“/etc”目录
cd ~ # "~"代表当前用户的“$HOME”目录，也就是“/home/{用户名}”目录。
ls # 在任何时候，您都可以使用“ls”命令，来了解当前目录下都有哪些文件。
```

远程路径：

远程路径的表示方法为 **协议://用户名:密码@位置/路径:端口**

大多数的远程路径可以使用默认端口匿名访问，由此用户名、密码、端口通常不需要填写，例如：

```shell
http://linuxtoy.org
```

要求身份验证的远程路径，您可以使用下面的方式访问：

```shell
ftp://user:passwd@ftp.linuxtoy.org:21
```

### 软件

Linux中没有注册表这个概念。安装软件，理论上讲，只要拷贝所有相关文件，并运行它的主程序就可以了。

按照传统，一个软件通常分别拷贝到同级目录下的bin、etc、lib、share等文件夹。

**bin**：可执行文件，程序的可执行文件通常在这个目录下。在环境变量中设定搜索路径，就可以直接执行，不需要定位其路径。

**etc**：配置文件，大部分系统程序的配置文件保存于/etc目录，便于集中修改。

**lib**：库文件，集中在一起，方便共享给不同程序。相较不同的软件单独保存库文件，能够节约一些磁盘空间。

**share**：程序运行所需要的其他资源，例如图标、文本。这部分文件是专有的，不需要共享；而且目录结构相对复杂，混放在一起比较混乱，所以单独存放。

还有一些软件，占用一个单独的目录，所有的资源都在这个目录中。类似于Windows下的绿色软件，不推荐在Linux系统下这样做。

- 执行时，系统找不到可执行文件（搜索所有路径，资源开销过大，是不现实的），需要定位其位置，像这样/home/user/bin/可执行文件，不够方便。
- 许多系统软件需要写作运行，配置文件分别保存，定位它们非常麻烦
- 如果程序使用的库文件，像图形库文件，都单独存放，那么磁盘空间的浪费会非常严重。

有一些大型软件，或者您部署的重要应用，您可以将它们单独安装在一个文件夹下。（通常源码安装支持这种方式）

### 配置方式

Linux下没有类似注册表的系统，系统和软件都可以通过纯文本的配置文件进行设置。

事实上，图形界面的配置工具，通常就是以图形界面的方式修改配置文件，适合设置一些比较简单的程序。如果软件有几千个可以配置的选项，全部做成菜单，想象一下。。。开始发抖吧。。。

图形界面的配置工具，可以看作特定配置文件专用编辑器。您一样可以使用通用文本编辑器来编辑配置文件，比如Nano、Gedit、Knote、Vim或者Emacs等等。不考虑阅读、修改配置文本所占用的时间，直接修改配置文件甚至更迅速（在以后的章节中，如果我们提示您修改某一文件，例如/etc/fstab。您可以使用任何顺手的文本编辑器打开它。）

如果只是要修改某一常用选项，并且时常修改，比如主机的IP地址。使用文本编辑器，您要找到相应的配置文件，还要在配置文件中找到相应的选项，会浪费掉您的时间和耐性。

图形配置工具经常会受各种因素制约，比如网络服务器中不提供图形服务，图形界面不够稳定。。。这时，您可以使用命令行的配置工具来完成这些工作。

例如：修改主机IP地址，可以使用ifconfig这个程序，执行下面的命令：

```shell
ifconfig eth0 192.168.0.1
```

### 隐藏文件

Linux下，名称中第一个字符为`.`的文件或者文件夹，系统会将它们隐藏起来。传统上，这种文件大多是用户的配置文件。

您可以尝试以下操作：

```shell
cd ~ # 进入您的用户目录
ls # 查看当前目录下的文件列表
ls -a # 查看所有文件列表（包括隐藏文件）
```

- 如果您只想查看隐藏文件，而不包括这两个特殊目录，您可以使用ls命令的选项 `-A`(ls -A)
- 每个目录下都包含两个特殊目录 `.`和 `..`您也许猜到了， `.`代表当前目录， `..`代表上一级目录。

现在，您可以看多许多文件名以`.`起始的文件或者文件夹了吧？使用`ls`命令无法显示它们。

### 文件类型

Linux系统主要根据文件头信息来判断文件类型，扩展名并非决定因素。

现在使用`ls -l` 命令，查看详细信息格式的文件列表，您将会看到如下内容：

```shell
total 5
drwxr-x--- 4  user  group    4096 Mar 10 00:37 filename
drwxr-xr-x 21 user  group		 4096 Mar 10 20:16 文件名
-rw------- 1  user  group    524  Mar 10 00:40 a
-rw-r--r-- 1  user  group    24   Jun 11 2000  b
drwx------ 2  user  group    4096 Mar  9 11:06 c
```

共显示了七列信息，从左至右依次为：权限、文件数、归属用户、归属群组、文件大小、创建日期、文件名称

```shell
d①rwxr-xr-x②
```

① 其中要特别留意的是第一列：

| 符号 | 含义         |
| ---- | ------------ |
| -    | 普通文件     |
| d    | 文件夹       |
| l    | 符号链接     |
| b    | 块设备文件   |
| c    | 字符设备文件 |
| s    | 套接文件     |
| p    | 管道文件     |

② 剩下的9个字符分为三组：分别是归属用户、归属群组、其他用户对于该文件的权限。我们看它的格式

| 符号 | 含义   |
| ---- | ------ |
| r    | 可读   |
| w    | 可写   |
| x    | 可执行 |

- 它们的顺序不能颠倒，某一位置为空（-），则表示不具有相应的权限。
- Linux下的可执行文件并不是由扩展名（例如 .exe）决定的，而是由其可执行权限位决定。
- 目录是一种特殊类型的文件。拥有目录的执行权限才可以进入这个目录！

### 权限

我们已经知道了，文件的权限分为r（可读）、w（可写）、x（可执行）三种类型，而一个文件可以针对归属用户，归属群组，其他用户或群组分别设定权限。

这种权限管理方式灵活、简单、严密、明晰。尽管如此，在最初的阶段，可能会有一点小小的不适。因为它无所不在，而您习惯了的Windows的权限管理却不是这样（非常混乱，大多数时间形同虚设，偶尔用到却让人伤透脑筋）。

使用`chmod`命令更改文件的权限，使用`chown`来更改文件的归属。例如：

```shell
chmod 755 xxx
chmod a+x xxx
chown user:group xxx #用来更改文件的归属用户。也可以同时更改其归属群组
chqrp group xxx # 用来更改文件的归属群组
```

上面命令中的755和a+x是两种类型的表达式

我们将在“权限管理”一节中详细介绍

#### 执行命令的权限

有一些命令，普通用户也可以执行，但是只有root用户才能执行成功，这是为什么呢？

例如在系统中增加一个新用户useradd，我们看看这个命令的程序文件

```shell
ls -l /usr/sbin/useradd
-rwxr-xr-x 1 root root 56156 2006-04-03 21:37 /usr/sbin/useradd
```

所有的用户都可以执行？

这是因为，useradd命令是修改/etc/passwd文件的一个工具，来看看这个文件：

```shell
ls -l /etc/passwd
-rw-r--r-- 1 root root 1835 2006-06-24 17:58 /etc/passwd
```

原来只有root用户才能写入修改结果，非root用户执行useradd命令当然不会有结果。

### 用户

在Linux系统中，有两种用户：普通用户、root用户

root用户拥有对系统的完全控制权。实际上这没有看上去那样的美妙，你必须对自己的行为负全部的责任。Linux继承了Unix的设计哲学：系统毫无保留的执行你下达的命令，哪怕这个命令是“向我开炮！”

普通用户只可以做系统允许的事情。尽管可以执行大多数命令，但是root专有的命令却不能成功的执行，因为这些命令往往关联着只有root才可以处理的文件。也就是说，普通用户通常只可以处理自己$HOME目录下的文件。详见“执行命令的权限”一节。

而作为root用户，可能会因为误操作给系统带来破坏；作为普通用户，可以做的事情又太少了点。

#### 执行命令的身份

默认情况下，您的命令提示符末尾$，这表示您将以普通用户的身份执行命令

您可以使用su （switch user）这命令来切换其他用户。

例如`su root`，切换到root用户（如果su命令后面没有参数，那么这个命令默认切换到root用户）

当您执行su这个命令，系统会提示您输入密码，请输入管理员的密码。这个时候，您会发现命令提示符末尾变成了#，您将以root用户的身份执行命令。

许多Linux系统随机设定系统root密码。这样更安全一些，这个时候您可以执行sudo命令，输入当前用户密码后，暂时以root用户的身份执行命令。（前提是sudoer列表中要包含您的ID）

> 使用visudo（需要root权限）可以将普通用户加入到sudoer列表中。

但即便是用sudo来执行，也不能保证系统不会在您的误操作下一命呜呼，更安全的办法是直接赋予用户某种操作的权限。

```shell
gpasswd -a user audio
```

这个命令将user加入到audio群组，您拥有了使用音频设备的权限。

事实上，Linux中一切皆文件，包括设备文件。

``` shell
ls -l /dev/sound

crw-rw---- 1 root audio 14, 	4 10-04 09:41 audio
crw-rw---- 1 root audio 14, 	3 10-04 09:41 dsp
crw-rw---- 1 root audio 14,   2 10-04 09:41 midi
crw-rw---- 1 root audio 14,   0 10-04 09:41 mixer
```

可以看到，和音频有关的设备文件，除了root用户可以使用，audio群组中的用户也可以使用

#### 群组

群组分为两种，主组和辅组。在/etc/passwd文件中，与用户相关联的是主组，每个用户只可以加入一个主组；/etc/group文件中则记录了每一个辅组所包含的用户，同一个用户可以被多个辅组所包含。

这样看起来有点乱，但却可以提供更大的灵活性。例如：

```shell
crw-rw---- 1 root audio 	/dev/sound/audio
brw-rw---- 1 root optical /dev/cdrom
```

先假设一名用户只可以属于一个群组：你是系统管理员，你管理的用户要求听点音乐，你把他加入了audio组；于是该用户把CD放进了光驱，结果一点反映也没有，于是为了让他使用cdrom，不得不让他拥有root权限，你将不能防范他可能作出的破坏。

而一名用户可以属于多个群组，能够很好的解决这个问题：你可以让用户既属于audio群组，又属于optical群组，这样他就可以用cdrom来听音乐，却没有root权限。

------

参考资料：

- [开源世界旅行手册](https://i.linuxtoy.org/docs/guide/)